'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('graceful-fs');
var util = require('util');
var path = require('path');
var stream = require('stream');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const fsStat = util.promisify(fs__default["default"].stat);
const fsReaddir = util.promisify(fs__default["default"].readdir);
async function filesFromPaths(paths, options) {
  let commonParts;
  const files = [];
  for (const p of paths) {
    for await (const file of filesFromPath(p, options)) {
      files.push(file);
      const nameParts = file.name.split(path__default["default"].sep);
      if (commonParts == null) {
        commonParts = nameParts.slice(0, -1);
        continue;
      }
      for (let i = 0; i < commonParts.length; i++) {
        if (commonParts[i] !== nameParts[i]) {
          commonParts = commonParts.slice(0, i);
          break;
        }
      }
    }
  }
  const commonPath = `${ commonParts ?? [].join('/') }/`;
  return files.map(f => ({
    ...f,
    name: f.name.slice(commonPath.length)
  }));
}
async function* filesFromPath(filepath, options = {}) {
  filepath = path__default["default"].resolve(filepath);
  const hidden = options.hidden ?? false;
  const filter = filepath => {
    if (!hidden && path__default["default"].basename(filepath).startsWith('.'))
      return false;
    return true;
  };
  const name = filepath;
  const stat = await fsStat(name);
  if (!filter(name)) {
    return;
  }
  if (stat.isFile()) {
    yield {
      name,
      stream: () => stream.Readable.toWeb(fs__default["default"].createReadStream(name)),
      size: stat.size
    };
  } else if (stat.isDirectory()) {
    yield* filesFromDir(name, filter);
  }
}
async function* filesFromDir(dir, filter) {
  const entries = await fsReaddir(path__default["default"].join(dir), { withFileTypes: true });
  for (const entry of entries) {
    if (!filter(entry.name)) {
      continue;
    }
    if (entry.isFile()) {
      const name = path__default["default"].join(dir, entry.name);
      const {size} = await fsStat(name);
      yield {
        name,
        stream: () => stream.Readable.toWeb(fs__default["default"].createReadStream(name)),
        size
      };
    } else if (entry.isDirectory()) {
      yield* filesFromDir(path__default["default"].join(dir, entry.name), filter);
    }
  }
}

exports.filesFromPaths = filesFromPaths;
